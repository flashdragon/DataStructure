실패는 필연적이다. 디스크가 실패합니다. 소프트웨어 버그는 물기에 적당한 조건을 기다리는 휴면 상태입니다. 사람들은 실수를 저지른다. 데이터 센터는 신뢰할 수없는 상용 하드웨어 팜에 구축됩니다. 클라우드 환경에서 실행중인 경우 이러한 요소 중 많은 부분이 사용자의 제어 범위를 벗어납니다. 문제를 복합화하기 위해 실패는 예측 가능하지 않으며 균일 한 확률 및 빈도로 발생하지 않습니다. 균일 한 주파수가 없으면 시스템의 불확실성과 위험이 증가합니다. 이러한 불가피하고 예측할 수없는 오류가 발생하더라도 사용자가 신뢰할 수있는 높은 수준의 가용성을 제공하는 안정적인 서비스를 어떻게 구축 할 수 있습니까? 순진한 접근법은 엄격한 분석을 통해 시스템의 정확성을 입증하려고 시도 할 수 있습니다. 실제 운영 환경을 에뮬레이트하거나 분석하는 또 다른 이론적 인 프레임 워크 또는 시뮬레이션을 통해 모든 유형의 실패를 모델링하고 시스템의 적절한 작동을 추론 할 수 있습니다. 불행히도 업계의 정적 분석 및 테스트 기술은 이러한 기능에 도달하지 못했습니다. 다른 접근 방식은 별도의 테스트 환경에서 모든 실패 모드를 시뮬레이트하기 위해 철저한 테스트 슈트를 만들려고 시도 할 수 있습니다. 각 테스트 스위트의 목표는 개별 구성 요소가 실패 할 때 전체 시스템뿐만 아니라 각 구성 요소의 적절한 기능을 유지하는 것입니다. 대부분의 소프트웨어 시스템은이 접근 방식을 단위 테스트와 통합 테스트의 조합과 함께 하나의 형식으로 사용합니다.
더 고급 사용법은 테스트의 커버리지 표면을 측정하여 완전 함을 나타냅니다.
이 접근 방식은 시스템의 품질을 향상시키고 대규모 클래스의 실패를 막을 수 있지만 대규모 분산 시스템에서 복원력을 유지하는 것은 불충분합니다. 분산 시스템은 데이터 및 정보 흐름으로 인한 문제를 해결해야합니다. 대상 시스템의 동작을 올바르게 캡처하는 테스트를 설계하고 실행하는 복잡성은 시스템 자체를 구축하는 것보다 큽니다. 대규모의 특성 위에 레이어를 추가하면 혁신과 기능 전달의 속도를 높게 유지하면서 실제로이를 실현할 수있는 현재의 수단으로 실현 불가능 해집니다.
이 기사에서 옹호 된 또 다른 접근법은 경험적으로 탄력성을 입증하고 의도 된 동작을 검증하기 위해 시스템에 오류를 유도하는 것입니다. 시스템이 장애에 대한 복원력으로 설계되었으므로 원래 설계 매개 변수 내에서 이러한 장애를 유도하면 시스템이 예상대로 작동하는지 검증합니다. 이 접근 방식은 실제 실제 시스템을 사용하기 때문에 등장하는 모든 탄력성 갭은 시스템이 진화하고 변화함에 따라 신속하게 식별되어 포착됩니다. 방금 설명한 두 번째 접근 방식에서는 테스트 환경에서 많은 복잡한 문제가 발견되지 않고 라이브 환경에서만 독특하고 드문 방식으로 나타납니다. 이것은 차례로 잠재적 인 버그가 발견되지 않고 누적 될 가능성을 높이고 올바른 실패 모드가 발생할 때만 큰 문제를 야기합니다. 오류 유도를 사용하면 테스트 환경에서 데이터, 정보 흐름 및 배포 아키텍처의 변화를 최소화해야 할 필요성이 최소화되고 문제를 놓칠 기회가 줄어 듭니다.
더 나아 가기 전에 탄력성이 의미하는 바가 무엇인지, 그리고 탄력성을 높이는 방법을 논의합시다.
탄력성은 전체 시스템에 장애가 발생하지 않는 방식으로 장애를 처리 할 수 ​​있도록 해주는 시스템의 속성입니다. 실패가 발생했을 때 블래스트 반경을 최소화하거나 실패한 구성 요소를 해결하기 위해 사용자 경험을 변경하는 작업이 포함될 수 있습니다.
예를 들어, 영화 추천 서비스가 실패하면, 사용자는 비 개인화 된 인기 타이틀 목록을 제공받을 수 있습니다. 복잡한 시스템은 끊임없이 다양한 수준의 오류를 겪고 있습니다. 탄력성은 현재와 미래 모두의 실패로부터 어떻게 회복 할 수 있는지, 또는 고립되어 있는지를 보여줍니다.
시스템의 복원력을 높이는 두 가지 방법이 있습니다.
• 리던던시 및 내결함성으로 애플리케이션을 구축하십시오. 
서비스 지향 아키텍처에서 구성 요소는 서비스에 캡슐화됩니다. 서비스는 클라이언트를 단일 또는 다중 장치 장애로부터 보호하는 중복 실행 장치 (인스턴스)로 구성됩니다. 전체 서비스가 실패하면 해당 서비스의 클라이언트는 장애를 지역화하고 계속 작동하도록 내결함성이 필요합니다.
• 정기적으로 실패를 유도하여 불확실성을 줄입니다.
 실패의 빈도를 높이면 불확실성과 부적절하거나 예기치 않은 대응 가능성이 줄어 듭니다. 응용 프로그램을 관찰하면서 각각의 고유 한 실패가 발생할 수 있습니다. 유도 된 실패에 대한 각각의 바람직하지 않은 반응에 대해, 제 1 접근법이 재발을 방지하기 위해 적용될 수있다. 실제로 가능한 모든 실패를 유도하는 것은 현실적이지 않지만, 가능한 열거의 연습
실패 및 우선 순위 지정은 허용 가능한 작동 조건을 이해하고 실패 범위를 벗어나는 장애를 분류하는 데 도움이됩니다.
첫 번째 항목은 다른 문헌에서 다룰 내용입니다. 이 기사의 나머지 부분은 두 번째 기사에 초점을 맞출 것이다.